name: Continuous Deployment

# Ce workflow construit et publie les images Docker (backend + frontend),
# puis dÃ©ploie les manifests Kubernetes situÃ©s dans le dossier k8s/.
on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      environment:
        description: "Nom de l'environnement Ã  dÃ©ployer (ex: staging, production)"
        required: true
        default: "staging"

env:
  # Registry cible. Adapter Ã  votre contexte (Docker Hub, ECR, etc.).
  REGISTRY: ghcr.io
  # Nom d'organisation / namespace du registre. Ex: ghcr.io/mon-compte.
  IMAGE_NAMESPACE: ${{ github.repository_owner }}
  BACKEND_IMAGE_NAME: recipes-backend
  FRONTEND_IMAGE_NAME: recipes-frontend

jobs:
  build-and-deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest
    # Permet d'associer le dÃ©ploiement Ã  un environnement GitHub pour la traÃ§abilitÃ©.
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: ðŸ›Žï¸ Checkout du dÃ©pÃ´t
        uses: actions/checkout@v4

      - name: ðŸ”§ PrÃ©paration de Docker Buildx
        # Buildx permet de construire des images optimisÃ©es et multiplateformes.
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Connexion au registre de conteneurs
        # Authentifie l'action pour pouvoir pousser les images.
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: ðŸ·ï¸ Calcul du tag d'image
        id: version
        # Utilise le tag Git si prÃ©sent ; sinon, gÃ©nÃ¨re un hash court du commit.
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            echo "value=${TAG}" >> "$GITHUB_OUTPUT"
          else
            echo "value=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"
          fi

      - name: ðŸ§± Build & Push backend
        # Construit l'image FastAPI et la pousse avec le tag calculÃ©.
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.BACKEND_IMAGE_NAME }}:${{ steps.version.outputs.value }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.BACKEND_IMAGE_NAME }}:latest

      - name: ðŸ§± Build & Push frontend
        # Construit l'image React. Adapter la commande si un build statique est prÃ©fÃ©rÃ©.
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ steps.version.outputs.value }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.FRONTEND_IMAGE_NAME }}:latest

      - name: â˜¸ï¸ Installation de kubectl
        uses: azure/setup-kubectl@v4

      - name: ðŸ—‚ï¸ Configuration de l'accÃ¨s cluster
        # RÃ©cupÃ¨re le kubeconfig encodÃ© en base64 depuis les secrets GitHub.
        run: |
          mkdir -p "$HOME/.kube"
          echo "${{ secrets.KUBE_CONFIG }}" | base64 --decode > "$HOME/.kube/config"
          chmod 600 "$HOME/.kube/config"

      - name: ðŸ“¦ Application des manifests Kubernetes
        # Applique le namespace, ConfigMaps, Secrets, Deployments, Services, Ingressâ€¦
        run: kubectl apply -k k8s

      - name: ðŸ”„ Mise Ã  jour des images dÃ©ployÃ©es
        # Force les Deployments Ã  utiliser les nouvelles images taguÃ©es.
        run: |
          BACKEND_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.BACKEND_IMAGE_NAME }}:${{ steps.version.outputs.value }}"
          FRONTEND_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ steps.version.outputs.value }}"
          kubectl set image deployment/backend backend="$BACKEND_IMAGE" -n recipes-app
          kubectl set image deployment/frontend frontend="$FRONTEND_IMAGE" -n recipes-app

      - name: âœ… VÃ©rification du rollout
        # Attends que les pods soient Ã  jour avant de conclure le dÃ©ploiement.
        run: |
          kubectl rollout status deployment/backend -n recipes-app --timeout=120s
          kubectl rollout status deployment/frontend -n recipes-app --timeout=120s
